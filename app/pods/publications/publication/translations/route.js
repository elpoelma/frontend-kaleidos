import Route from '@ember/routing/route';
import { action } from '@ember/object';
import { PAGE_SIZE } from 'frontend-kaleidos/config/config';
import { tracked } from '@glimmer/tracking';

// use:
// - isPieceDeletable property
// - file property avoids error when piece (and file) are deleted
export class TranslationRow {
  @tracked piece;
  @tracked date;
  @tracked requestActivity;
  @tracked requestActivitiesUsedBy;

  // no async constructor() in JS
  static async create(piece,requestActivity) {
    const row = new TranslationRow();
    console.log(piece)
    console.log(requestActivity)
    if (piece){
      row.piece = piece;
      row.date = piece.created;
      row.requestActivitiesUsedBy = await piece.requestActivitiesUsedBy;
    }
    if (requestActivity) {

      row.requestActivity = requestActivity;
      row.date = requestActivity.startDate;
    }
    return row;
  }

  get isPieceDeletable() {
    // can be translation or publication related
    const isUsedInRequest = this.requestActivitiesUsedBy.length > 0;
    // receivedDate is set if and only if it is a received pieced
    const isReceived = !!this.piece.receivedDate;
    const isUsed = isUsedInRequest || isReceived;
    return !isUsed;
  }
}
export default class PublicationsPublicationTranslationsRoute extends Route {
  async model() {
    this.translationSubcase = await this.modelFor('publications.publication').translationSubcase;

    const requestActivities = this.store.query('request-activity',
      {
        'filter[translation-subcase][:id:]': this.translationSubcase.id,
        include: 'translation-activity,translation-activity.generated-pieces,translation-activity.generated-pieces.file,email,used-pieces,used-pieces.file',
        sort: '-start-date',
      }
    );


    const requestRows = await Promise.all(requestActivities.map((request) => TranslationRow.create(0,request)));
    console.log(requestRows)
    const queryProperties = {
      include: [
        'file',
        'publication-subcase-source-for',
        'request-activities-used-by'
      ].join(','),
      'page[size]': PAGE_SIZE.PUBLICATION_FLOW_PIECES,
    };

    // Fetching all documents for the translation-subcase is split into multiple requests on purpose.
    // It seems when using a single request on translation-subcase with an include query param
    // for pieces (via the different paths) ember-data does not catch the inverse relation
    // from piece to translation-subcase. This results in an additional request per piece
    // when piece.translationSubcaseSourceFor is used in the template.

    // Source documents uploaded on the translation subcase
    const sourceDocumentsQuery = this.store.query('piece', {
      'filter[translation-subcase-source-for][:id:]': this.translationSubcase.id,
      ...queryProperties,
    });

    // Received translation documents generated by a translation-activity
    const generatedPiecesQuery = this.store.query('piece', {
      'filter[translation-activity-generated-by][subcase][:id:]': this.translationSubcase.id,
      ...queryProperties,
    });

    let pieces = await Promise.all([sourceDocumentsQuery, generatedPiecesQuery]);
    pieces = pieces.flatMap((pieces) => pieces.toArray());
    pieces = new Set(pieces); // using set to ensure a collection of unique pieces

    pieces = [...pieces];
    const pieceRows = await Promise.all(pieces.map((piece) => TranslationRow.create(piece,null)));

    let translationRows= [pieceRows,requestRows];
    translationRows = translationRows.flatMap((row) => row.toArray())
    translationRows = translationRows.sortBy('date').reverseObjects();

    console.log(translationRows)
    return translationRows;
  }

  async afterModel() {
    this.publicationFlow = this.modelFor('publications.publication');
    this.publicationSubcase = await this.publicationFlow.publicationSubcase;
  }

  setupController(controller) {
    super.setupController(...arguments);
    controller.publicationFlow = this.publicationFlow;
    controller.translationSubcase = this.translationSubcase;
    controller.publicationSubcase = this.publicationSubcase;
    controller.selectedPieceRows = [];
  }

  @action
  refresh() {
    super.refresh();
  }
}
