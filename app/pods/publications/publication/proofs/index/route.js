import Route from '@ember/routing/route';
import { action } from '@ember/object';
import { PAGE_SIZE } from 'frontend-kaleidos/config/config';
import { tracked } from '@glimmer/tracking';
import { inject as service } from '@ember/service';

export class ProofRow {
  @tracked piece;
  @tracked date;
  @tracked requestActivity;

  // no async constructor() in JS
  static async create(piece,requestActivity) {
    const row = new ProofRow();

    if (piece){
      row.piece = piece;
      row.date = piece.created;
    }
    if (requestActivity) {
      row.requestActivity = requestActivity;
      row.date = requestActivity.startDate;
    }
    return row;
  }
}
export default class PublicationsPublicationProofsRoute extends Route {
  @service store;

  async model() {
    this.publicationSubcase = await this.modelFor('publications.publication').publicationSubcase;

    let requestActivities = await this.store.query('request-activity',
      {
        'filter[publication-subcase][:id:]': this.publicationSubcase.id,
        include: [
          'email',
          'used-pieces',
          'used-pieces.file',
          'proofing-activity',
          'proofing-activity.generated-pieces',
          'proofing-activity.generated-pieces.file',
          'publication-activity'
        ].join(','),
        sort: '-start-date',
      }
    );
    let requestRows = await Promise.all(requestActivities.map((request) => ProofRow.create(null,request)));

    // Received translation documents generated by a translation-activity
    const pieces = await this.store.query('piece', {
      'filter[proofing-activity-generated-by][subcase][:id:]': this.publicationSubcase.id,
      include: [
        'file',
        'publication-subcase-correction-for',
      ].join(','),
      'page[size]': PAGE_SIZE.PUBLICATION_FLOW_PIECES,
    });

    const pieceRows = await Promise.all(pieces.map((piece) => ProofRow.create(piece,null)));

    let translationRows= [pieceRows,requestRows];
    translationRows = translationRows.flatMap((row) => row.toArray())
    translationRows = translationRows.sortBy('date').reverseObjects();

    return translationRows;
  }

  async afterModel() {
    this.publicationFlow = this.modelFor('publications.publication');
  }

  setupController(controller) {
    super.setupController(...arguments);
    controller.publicationFlow = this.publicationFlow;
    controller.publicationSubcase = this.publicationSubcase;
  }

  @action
  refresh() {
    super.refresh();
  }
}
